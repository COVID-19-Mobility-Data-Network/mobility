---
title: "Fitting and simulating a gravity model"
output: rmarkdown::html_vignette
header-includes:
   - \usepackage{amsmath}
   - \usepackage{amssymb}
   - \usepackage{amsfonts}
vignette: >
  %\VignetteIndexEntry{Fitting and simulating a gravity model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(mobility)
library(ggplot2)
library(reshape2)
library(viridis)
library(ggstance)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  autodep=TRUE
)
```

Historically, the gravity model has been used to model connectivity among locations based on the distances among $i$ origins and $j$ destinations ($d_{ij}$) and population sizes of each location ($N_i$ and $N_j$). A major advantage of the gravity model is that distance and population size are simple covariates that can be obtained in almost any context, allowing a researcher to infer connectivity with little information. 

When fitting the gravity model to data, we also need a matrix of observed travel volume ($M$). Travel volume is an intentionally vague term here because a mobility data matrix can be populated with a variety of measurements that capture relative amounts of travel among locations. For example, if we are using Call Data Records (CDR) which are measures of mobile phone usage supplied by mobile phone companies, the unit of travel volume is likely to be the total number of person trips per unit time. Or if we are using a travel survey that researchers have collated from questionares given to residents of an area, the measurement of travel volume might be the total number of individuals that reported travelling from $i$ to $j$ in the past month. 

The actual unit of travel volume is less important when modeling connectivity because the gravity model formula estimates relative travel volume that is normalized across all $j$ destinations of an origin, so that the rows of $M$ sum to 1. However, it is important that all $ij$ cells in $M$ have the **same** unit of travel volume per unit time because the model estimates parameters based on relative differences in travel volume.

The rest of this vignette shows an example of how to estimate and simulate connectivity ($\hat{\pi}_{ij}$) for all possible $i \rightarrow j$ travel routes found in supplied data matrices ($M$, $D$, and $N$).

### Build data matrices
Before we can fit a gravity model, we must build data matrices from the longform travel data. The utility functions `get_mob_matrix()`, `get_distance_matrix()`, and `get_pop_vec()` can be used to generate data matrices representing travel volume among locations ($M$), along with distances ($D$) and population sizes ($N$). Here we use pre-built matrices from simulated data in the `mobiliy_matrices()` data object.
```{r data}
M <- mobility_matrices$M
D <- mobility_matrices$D
N <- mobility_matrices$N
```

By design, we have added additional stochasticity around trip counts in the movement matrix ($M$) and randomly sampled 80% of observed routes to simulate missing observations, which are shown as grey cells in the plot below.

```{r data_plot, fig.height=6.5, fig.width=6.5}
ggplot(data=melt(M)) +
  geom_tile(aes(x=factor(destination),
                y=factor(origin),
                fill=value)) +
  xlab('Destination') + ylab("Origin") +
  theme_bw() + theme(axis.text.x=element_text(size=10),
                     axis.text.y=element_text(size=10),
                     axis.title.x=element_text(size=12, margin = margin(t = 15)),
                     axis.title.y=element_text(size=12, margin = margin(r = 15)),
                     legend.position='bottom') +
  viridis::scale_fill_viridis(option='inferno', direction=1) +
  guides(fill=guide_colorbar(title='Observed trips',
                             title.position='top',
                             label.theme=element_text(size=9),
                             barwidth=20,
                             barheight=0.5,
                             frame.colour='black',
                             ticks=TRUE))
```


### Fit gravity model to data
Gravity model parameters can be estimated using the `fit_gravity()` function. This function uses the distance among locations ($D$) and population sizes ($N$) as covariates in the gravity equation, which is fitted to the movement matrix ($M$) with a Poisson likelihood link function:
$$
\begin{aligned}
        m_{ij} &\sim \text{Poisson}\big(\pi_{ij}N_{i}\big)\\
        \pi_{ij} &= c_{ij}/\sum_{\forall j}c_{ij} \\
        c_{ij} &= \theta \Bigg(
        \frac{
        N_{i}^{\omega_1} N_{j}^{\omega_2}
        }{
        d_{ij}
        } \Bigg)
\end{aligned}   
$$
Gravity model parameters are fit through normalized connectivity values ($\pi_{ij}$) that scale the Poission likelihood so that it is proportional to the observed trip counts ($m_{ij}$). The exponential parameters $\omega_1$ and $\omega_2$ are weights that modify the contribution of origin and destination population sizes, and $\theta$ is a proportionality constant. The denominator of the gravity model, $d_{ij}^\gamma$, serves as the dispersal kernel function. The fitting function `fit_gravity()` estimates the posterior distribution of model parameters using Bayesian MCMC inference.

```{r fit}
mod <- fit_gravity(M=M, 
                   D=D, 
                   N=N,
                   n_chain=2,
                   n_burn=1000,
                   n_samp=1000,
                   n_thin=2,
                   DIC=TRUE)
```

The above code fits the gravity model using 4 sampling chains, discards the first 1000 samples as 'burin in', and then takes 1000 samples thinning by 2 to give 500 total samples per chain. The `DIC=TRUE` argument tells the function to calculate the Deviance Information Criterion (DIC). 

Running a gravity model on a large number of locations (e.g. $\gt 100$) or drawing a large number of samples from posterior distributions (e.g. 10000) may take several minutes. If computation is cumbersome, then the model can run sampling chains in parallel instead of sequentially by specifying `parallel = TRUE`.

The fitting function `fit_gravity()` returns results as a `coda::mcmc.list()` object shown below. The `coda::mcmc.list()` is a common object class that holds the posterior samples for each parameter and each sampling chain.
```{r chains}
str(mod)
```

### Model summary and validation
To calculate summary statistics of estimated parameter values, you can supply a fitted model object to the `summarize_mobility()` function. This function is a wrapper for the `MCMCvis::MCMCsummary()` function that calculates summary statistics for each parameter across each chain along with convergance diagnosics like the Gelman-Rubin convergence diagnostic and ($\hat{R}$) and samples auto-correlation foreach parameter.
```{r summary}
mod <- summarize_mobility(mod)
mod
```

The `check_mobility()` function provides goodness of fit metrics and summary plots.
```{r check, fig.height=4.5, fig.width=7.25}
check_mobility(M, D, N, mod)
```

Now that we have verified that our model fits the data adequately, we can simulate connectivity values among the off-diagonal locations by using the estimated parameter values from the fitted gravity model in the `sim_gravity()` function.

```{r sim}
pi_hat <- sim_gravity(N=N,
                      D=D,
                      theta=mod['theta', 'Mean'],
                      omega_1=mod['omega_1', 'Mean'],
                      omega_2=mod['omega_2', 'Mean'],
                      gamma=mod['gamma', 'Mean'])
```

```{r sim_plot, fig.height=6.5, fig.width=6.5}
diag(pi_hat) <- NA

ggplot(data=melt(pi_hat)) +
  geom_tile(aes(x=factor(destination),
                y=factor(origin),
                fill=value)) +
  xlab('Destination') + ylab("Origin") +
  theme_bw() + theme(axis.text.x=element_text(size=10),
                     axis.text.y=element_text(size=10),
                     axis.title.x=element_text(size=12, margin = margin(t = 15)),
                     axis.title.y=element_text(size=12, margin = margin(r = 15)),
                     legend.position='bottom') +
  viridis::scale_fill_viridis(option='inferno', direction=1) +
  guides(fill=guide_colorbar(title='Observed proportion of trips',
                             title.position='top',
                             label.theme=element_text(size=9),
                             barwidth=20,
                             barheight=0.5,
                             frame.colour='black',
                             ticks=TRUE))
```

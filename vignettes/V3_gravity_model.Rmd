---
title: "Fitting and simulating a gravity model"
output: rmarkdown::html_vignette
header-includes:
   - \usepackage{amsmath}
   - \usepackage{amssymb}
   - \usepackage{amsfonts}
vignette: >
  %\VignetteIndexEntry{Fitting and simulating a gravity model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(mobility)
library(ggplot2)
library(reshape2)
library(viridis)
library(ggstance)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  autodep=TRUE
)
```

### Build data matrices
Before we can fit a gravity model, we must build data matrices from the longform travel data. The utility functions `get_mob_matrix`, `get_distance_matrix`, and `get_pop_vec` can be used to generate data matrices representing travel among locations ($M$), along with distances ($D$) and population sizes ($N$). Here we use pre-built matrices from simulated data in the `mobiliy_matrices` data object.
```{r data}
M <- mobility_matrices$M
D <- mobility_matrices$D
N <- mobility_matrices$N
```

By design, we have added additional stochasticity around trip counts in the movement matrix ($M$) and randomly sampled 50% of observed routes to simulate missing observations, which are shown as grey cells in the plot below.

```{r data_plot, fig.height=6.5, fig.width=6.5, echo=FALSE}
ggplot(data=melt(M)) +
  geom_tile(aes(x=factor(destination),
                y=factor(origin),
                fill=value)) +
  xlab('Destination') + ylab("Origin") +
  theme_bw() + theme(axis.text.x=element_text(size=10),
                     axis.text.y=element_text(size=10),
                     axis.title.x=element_text(size=12, margin = margin(t = 15)),
                     axis.title.y=element_text(size=12, margin = margin(r = 15)),
                     legend.position='bottom') +
  viridis::scale_fill_viridis(option='inferno', direction=1) +
  guides(fill=guide_colorbar(title='Observed trips',
                             title.position='top',
                             label.theme=element_text(size=9),
                             barwidth=20,
                             barheight=0.5,
                             frame.colour='black',
                             ticks=TRUE))
```


### Fit gravity model to data
Gravity model parameters can be estimated using the `fit_gravity` function. This function uses the distance among locations ($D$) and population sizes ($N$) as covariates in the gravity equation, which is fitted to the movement matrix ($M$) with a Poisson likelihood link function:
$$
\begin{aligned}
        m_{ij} &\sim \text{Poisson}\big(\pi_{ij}N_{i}\big)\\
        \pi_{ij} &= c_{ij}/\sum_{\forall j}c_{ij} \\
        c_{ij} &= \theta \Bigg(
        \frac{
        N_{i}^{\omega_1} N_{j}^{\omega_2}
        }{
        d_{ij}
        } \Bigg)
\end{aligned}   
$$
Gravity model parameters are fit through normalized connectivity values ($\pi_{ij}$) that scale the Poission likelihood so that it is proportional to the observed trip counts ($m_{ij}$). The exponential parameters $\omega_1$ and $\omega_2$ are weights that modify the contribution of origin and destination population sizes, and $\theta$ is a proportionality constant. The denominator of the gravity model, $d_{ij}^\gamma$, serves as the dispersal kernel function. The fitting function `fit_gravity` estimates the posterior distribution of model parameters using Bayesian MCMC inference.

```{r fit}
mod <- fit_gravity(M, D, N, DIC=TRUE)
```

The above code fits the gravity model using 4 sampling chains, discards the first 1000 samples as 'burin in', and then takes 5000 samples thinning by 5 to give 1000 total samples per chain. Additional arguments tell the function to calculate the Deviance Information Criterion (DIC) and to execute the model computation on 4 parallel cores. Running this model on a large number of locations may take several minutes.

The fitting function `fit_gravity` returns results as an `mcmc.list` object shown below.
```{r chains}
str(mod)
```

### Model summary and validation
To calculate summary statistics of estimated parameter values, you can supply a fitted model object to the `summarize_mobility` function.
```{r summary}
mod <- summarize_mobility(mod)
mod
```

The `check_gravity` function provides goodness of fit metrics and summary plots.
```{r check, fig.height=4.5, fig.width=7.25}
check_gravity(M, D, N, mod)
```

Now that we have verified that our model fits the data adequately, we can simulate connectivity values among the off-diagonal locations by using the estimated parameter values from the fitted gravity model in the `sim_gravity` function.

```{r sim}
M_hat <- sim_gravity(N=N,
                     D=D,
                     theta=mod['theta', 'Mean'],
                     omega_1=mod['omega_1', 'Mean'],
                     omega_2=mod['omega_2', 'Mean'],
                     gamma=mod['gamma', 'Mean'],
                     counts=FALSE)
```

```{r sim_plot, fig.height=6.5, fig.width=6.5, echo=FALSE}
diag(M_hat) <- NA

ggplot(data=melt(M_hat)) +
  geom_tile(aes(x=factor(destination),
                y=factor(origin),
                fill=value)) +
  xlab('Destination') + ylab("Origin") +
  theme_bw() + theme(axis.text.x=element_text(size=10),
                     axis.text.y=element_text(size=10),
                     axis.title.x=element_text(size=12, margin = margin(t = 15)),
                     axis.title.y=element_text(size=12, margin = margin(r = 15)),
                     legend.position='bottom') +
  viridis::scale_fill_viridis(option='inferno', direction=1) +
  guides(fill=guide_colorbar(title='Observed proportion of trips',
                             title.position='top',
                             label.theme=element_text(size=9),
                             barwidth=20,
                             barheight=0.5,
                             frame.colour='black',
                             ticks=TRUE))
```

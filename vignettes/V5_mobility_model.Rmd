---
title: "Fitting and simulating a full mobility model"
output: rmarkdown::html_vignette
bibliography: references.bib
header-includes:
   - \usepackage{amsmath}
   - \usepackage{amssymb}
   - \usepackage{amsfonts}
vignette: >
  %\VignetteIndexEntry{Fitting and simulating a full mobility model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
library(mobility)
library(ggplot2)
library(reshape2)
library(viridis)
library(ggstance)
library(foreach)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  autodep=TRUE
)

set.seed(1234)
```

So, what do we mean by "mobility" model? The mobility model estimated by this package is different from using just a gravity model in that it estimates values along the diagonal of the mobility matrix ($\hat{M}_{ii}$), unlike gravity model formulations which only estimate off-diagonal values ($\hat{M}_{ij}$). This is acheived by combining models that estimate: 1) the probabilty of travel outside the origin location $i$ ($\tau_i$) which helps us to fill in the diagonal of the mobility matrix, and 2) the distribution of travel from the origin location $i$ to all $j$ destinations ($\pi_{ij}$) which fills in the off-diagonal elements. 

A common problem with mobility data, regardless of the source, is missing observations. This occurs when some $i \rightarrow j$ routes in the mobility data matrix were not observed during the time interval of data collection, or in the case of travel survey data, questions about travel may be collected for only a few locations. However, the role of a mobility matrix in other models (e.g. disease transmission models) is often to supply connecetivity or travel volume for all possible routes of travel among locations. Therefore, the model fitting and simulation functions in this package are designed to help estimate $\tau_i$ and $\pi_{ij}$ for missing locations and allow extrapolation to other spatial scales.

The following vignette will use simulated data to give an example of how a full mobility model can be estimated and simulated. Both models described below can be fitted to data independently using the `fit_prob_travel()` and `fit_gravity()` functions. The `fit_mobility()` function is a wrapper that combines these models to estimate both diagonal and off-diagonal elements of the mobility matrix. The `check_mobility()` and `sim_mobility()` function then facilitate model validation and stochastic simulation of the fitted mobility model.


## Build data matrices
Before we can fit a mobility model, we must build data matrices from the longform travel data. The utility functions `get_mob_matrix()`, `get_distance_matrix()`, and `get_pop_vec()` can be used to generate data matrices representing travel among locations ($M$), along with distances ($D$) and population sizes ($N$). Here we use pre-built matrices from simulated data in the `mobiliy_matrices()` data object.
```{r data}
M <- mobility_matrices$M
D <- mobility_matrices$D
N <- mobility_matrices$N
```

By design, we have added additional stochasticity around trip counts in the movement matrix ($M$) and randomly sampled 80% of observed routes to simulate missing observations, which are shown as grey cells in the plot below.

```{r data_plot, fig.height=6.5, fig.width=6.5, echo=FALSE}
ggplot(data=melt(M)) +
  geom_tile(aes(x=factor(destination),
                y=factor(origin),
                fill=value)) +
  xlab('Destination') + ylab("Origin") +
  theme_bw() + theme(axis.text.x=element_text(size=10),
                     axis.text.y=element_text(size=10),
                     axis.title.x=element_text(size=12, margin = margin(t = 15)),
                     axis.title.y=element_text(size=12, margin = margin(r = 15)),
                     legend.position='bottom') +
  viridis::scale_fill_viridis(option='inferno', direction=1) +
  guides(fill=guide_colorbar(title='Observed trips',
                             title.position='top',
                             label.theme=element_text(size=9),
                             barwidth=20,
                             barheight=0.5,
                             frame.colour='black',
                             ticks=TRUE))
```

## Estimate probability of travel outside each origin location
To estimate the probability of traveling outside the origin location $i$, the `fit_mobility()` function uses a Beta-Binomial model with hierarchical structure to infer travel probability in unobserved locations.
$$
y_i \sim \text{Binom}(\tau_i, \sum_{j} M_{ij})
$$
The random variable $y_i$ is the observed number of trips that leave origin $i$ within the time interval. Binomial parameters $\tau_i$ and $n_i$ are the success probability and total number of observed trips in origin $i$ respectively. In the absence of a linear predictor containing covariates, the conjugate prior distribution for a Binomial likelihood is the Beta distribution (a random variable between 0 and 1). Therefore, success probabilities $\tau_i$ are assumed to be independent samples drawn from a Beta distributed prior with shape and rate parameters $\alpha$ and $\beta$ [@gelman_bayesian_2003]. 
$$
\begin{aligned}
\tau_i &\sim \text{Beta}(\alpha, \beta) \\
\tau_\text{pop} &\sim \text{Beta}(\bar{\alpha}, \bar{\beta})
\end{aligned}
$$
The hierarchical structure comes from estimating $\alpha$ and $\beta$ as population-level hyper-priors for the origin-level probabilities $\tau_i$, where $\tau_\text{pop}$ captures the overall population-level mean with a distribution denoted as $\text{Beta}(\bar{\alpha}, \bar{\beta})$. 
$$
\begin{aligned}
\alpha &\sim \text{Gamma}(1,0.1) \\
\beta &\sim \text{Gamma}(1,0.1)
\end{aligned}
$$  

This structure allows origin locations to have probabilities $\tau_i$ which are driven by data in each location and all unobserved locations regress to the population mean $\tau_\text{pop}$.

```{r fit_prob_travel}
total <- rowSums(M, na.rm=TRUE)
prob_trav <- summarize_mobility(
  fit_prob_travel(travel=total-diag(M), 
                  total=total)
)
```

```{r, echo=FALSE, fig.width=5, fig.height=7}
ggplot(data=prob_trav) +
  geom_point(aes(x=Mean, y=rownames(prob_trav)), size=2) +
  ggstance::geom_linerangeh(aes(y=rownames(prob_trav), xmin=HPD2.5, xmax=HPD97.5)) +
  xlim(0,1) +
  xlab('Probability of travel outside origin') + ylab('Origin') +
  theme_bw() + theme(axis.text.x=element_text(size=9),
                     axis.text.y=element_text(size=9),
                     axis.title.x=element_text(size=12, margin = margin(t = 15)),
                     axis.title.y=element_text(size=12, margin = margin(r = 15)),
                     legend.position='right')
```

## Estimate probability of travel between origins and destinations using gravity model
The `fit_mobility()` function estimates gravity model parameters using the distance among locations ($D$) and population sizes ($N$) as covariates in the gravity equation, which is fitted to the off-diagonal elements of the movement matrix ($M$). The model formula used a Poisson likelihood link function with the following specification:
$$
\begin{aligned}
        m_{ij} &\sim \text{Poisson}\big(\pi_{ij}N_{i}\big)\\
        \pi_{ij} &= c_{ij}/\sum_{\forall j}c_{ij} \\
        c_{ij} &= \theta \Bigg(
        \frac{
        N_{i}^{\omega_1} N_{j}^{\omega_2}
        }{
        d_{ij}
        } \Bigg)
\end{aligned}   
$$
Gravity model parameters are fit through normalized connectivity values ($\pi_{ij}$) that scale the Poission likelihood so that it is proportional to the observed trip counts ($m_{ij}$). The exponential parameters $\omega_1$ and $\omega_2$ are weights that modify the contribution of origin and destination population sizes, and $\theta$ is a proportionality constant. The denominator of the gravity model, $d_{ij}^\gamma$, serves as the dispersal kernel function. The fitting function estimates the posterior distribution of model parameters using Bayesian MCMC inference.


## Combining models to estimate full mobility matrix
Thus far we have estimated $\pi_{ij}$ (the probability of leaving origin $i$) and $\pi_{ij}$ (the probability of going from $i$ to $j$). The values of $\pi_{ij}$ sum to unity along each row, but the diagonal is missing, indicating that this is a relative quantity. That is to say, $\pi_{ij}$ gives the probability of going from $i$ to $j$ **given** that travel outside origin $i$ occurs. Therefore, we can use basic conditional probability rules [@blitzstein_introduction_2014] to define the travel routes in the off-diagonals.
$$
\Pr( \text{leave}_i, \text{travel}_{i \rightarrow j}) = \Pr( \text{travel}_{i \rightarrow j} \mid \text{leave}_i ) \Pr(\text{leave}_i ) = \pi_{ij} \tau_i. 
$$
The diagonal elements then represent the probability of staying in the origin location $i$, represented as the complement of $\tau_i$:
$$
\Pr( \text{stay}_i) =  1 - \tau_i.
$$
Now each row of the estimated mobility matrix $\hat{M}$ sum to 1 including the diagonal to give the absolute probability of travel **within** origins and **among** origins and destinations.

## Fitting a mobility model to data
The parameters that give $\pi_{ij}$ and $\pi_{ij}$ can be estimated using the `fit_mobility()` function:
```{r fit mobility}
mod <- summarize_mobility(
  fit_mobility(M, D, N),
  ac_lags=5
)
mod
```

The model output printed above tells us that locations named D, I, and J were missing data and that these locations will inherit the population mean for $\tau$. Other summary statistics tell us that, although the model converged for all parameters ($\hat{R} \approx 1$) we should have run more samples for this example because effective sample sizes ($SS_{\text{eff}}$) were low ($\lt 1000$) for several parameters. We can improve effective sample sizes of increasing any of the `n_chain`, `n_burn`, `n_samp`, or `n_thin` arguments.

## Checking the goodness of fit of a mobility model
It is important to validate whether a fitted model is capturing the trends in the supplied mobility data. The `check_mobility()` function will calculate goodness of fit measures for a fitted model object.
```{r check mobility, fig.height=4, fig.width=7}
check_mobility(M=M,
               D=D,N=N,
               mod=mod)
```
At first glance, our model seems to be doing a good job of capturing trends in the data. The posterior predictive check shows that if we just look at the overall distribution of trip counts in the mobility data matrix ($M$), that the model is predicting trip counts with about the same distribution. The Q-Q plot shows how the quantiles of the residuals of our model compare to the quantiles expected from a Normal distribution. We also see that the residuals are mostly Normally distributed with some deviation at the extremes.

The prediction error results compare actual trip count values in the data matrix $M$ with the predicted values of the estimated mobility model ($\hat{M}$). These results indicate that our model has an average magnitude of error of about 517 trip counts (RMSE), which is on average about 60% of the observed trip count values. The R-squared value shows that our model captures approximately 85% of the variance observed in the supplied mobility data.


## Simulating a mobility matrix from a fitted model
Now that we have a fitted mobility model that fits the data well, we can now simulate values for the routes that are missing in the original data matrix $M$. Values of $\hat{M}$ can then be simulated with the `sim_mobility()` function. The code below shows how to produce a simple point estimate prediction of $\hat{M}$ using mean parameter values from the fitted model.
```{r sim mobility point}
mod_sim <- sim_mobility(D,
                        N,
                        theta = mod['theta','Mean'],
                        omega_1 = mod['omega_1','Mean'],
                        omega_2 = mod['omega_2','Mean'],
                        gamma = mod['gamma','Mean'],
                        tau = mod[grep('tau', rownames(mod)),'Mean'])
mod_sim[1:5,1:5]
```

For applications where we want to simulate stochastic realizations of the mobility matrix based on the uncertainty in model parameters, such as in a spatial disease transmission model, we can give the `sim_mobility()` function the model object fitted by `fit_mobility()` and ask for `n` stochastic realizations. The following code will return a three-dimensional array where the third dimension contains the `n` simultions.

```{r sim mobility stoch}
mod_sim <- sim_mobility(D,
                        N,
                        mod=mod,
                        n=3)
mod_sim[1:5,1:5,]
```


## References

<div id="refs"></div>
